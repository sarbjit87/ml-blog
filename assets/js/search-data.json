{
  
    
        "post0": {
            "title": "Title",
            "content": "Linear Regression with&#160;PyTorch . In a linear regression model, each target variable is estimated to be a weighted sum of the input variables, offset by some constant, known as a bias : . yield_apple = w11 * temp + w12 * rainfall + w13 * humidity + b1 yield_orange = w21 * temp + w22 * rainfall + w23 * humidity + b2 . The learning part of linear regression is to figure out a set of weights w11, w12,... w23, b1 &amp; b2 by looking at the training data, to make accurate predictions for new data (i.e. to predict the yields for apples and oranges in a new region using the average temperature, rainfall and humidity). This is done by adjusting the weights slightly many times to make better predictions, using an optimization technique called gradient descent. . We begin by importing Numpy and PyTorch: . import numpy as np import torch . Training data . The training data can be represented using 2 matrices: inputs and targets, each with one row per observation, and one column per variable. Let&#39;s assume some random data for temp, rainfall and humidity being represented in a numpy array. . # Input (temp, rainfall, humidity) inputs = np.array([[73, 67, 43], [91, 88, 64], [87, 134, 58], [102, 43, 37], [69, 96, 70]], dtype=&#39;float32&#39;) . # Targets (apples, oranges) targets = np.array([[56, 70], [81, 101], [119, 133], [22, 37], [103, 119]], dtype=&#39;float32&#39;) . Let&#39;s convert these to tensors now. . # Convert inputs and targets to tensors inputs = torch.from_numpy(inputs) targets = torch.from_numpy(targets) print(inputs) print(targets) . tensor([[ 73., 67., 43.], [ 91., 88., 64.], [ 87., 134., 58.], [102., 43., 37.], [ 69., 96., 70.]]) tensor([[ 56., 70.], [ 81., 101.], [119., 133.], [ 22., 37.], [103., 119.]]) . Linear regression model from&#160;scratch . The weights and biases (w11, w12,... w23, b1 &amp; b2) can also be represented as matrices, initialized as random values. The first row of w and the first element of b are used to predict the first target variable i.e. yield of apples, and similarly the second for oranges. . # Weights and biases w = torch.randn(2, 3, requires_grad=True) b = torch.randn(2, requires_grad=True) print(w) print(b) . tensor([[ 0.0991, 0.9799, -0.9378], [-0.4636, -0.4386, -0.7802]], requires_grad=True) tensor([-0.5751, -0.7712], requires_grad=True) . torch.randn creates a tensor with the given shape, with elements picked randomly from a normal distribution with mean 0 and standard deviation 1. . Our model is simply a function that performs a matrix multiplication of the inputs and the weights w (transposed) and adds the bias b (replicated for each observation). . . We can define the model as follows: . def model(x): return x @ w.t() + b . @ represents matrix multiplication in PyTorch, and the .t method returns the transpose of a tensor. . The matrix obtained by passing the input data into the model is a set of predictions for the target variables. . # Generate predictions preds = model(inputs) print(preds) . tensor([[ 31.9884, -97.5489], [ 34.6570, -131.4889], [ 84.9622, -145.1297], [ 16.9713, -95.7842], [ 34.6894, -129.4807]], grad_fn=&lt;AddBackward0&gt;) . Let&#39;s compare the predictions of our model with the actual targets. . # Compare with targets print(targets) . tensor([[ 56., 70.], [ 81., 101.], [119., 133.], [ 22., 37.], [103., 119.]]) . You can see that there&#39;s a huge difference between the predictions of our model, and the actual values of the target variables. Obviously, this is because we&#39;ve initialized our model with random weights and biases, and we can&#39;t expect it to just work. . Loss function . Before we improve our model, we need a way to evaluate how well our model is performing. We can compare the model&#39;s predictions with the actual targets, using the following method: . Calculate the difference between the two matrices (preds and targets). | Square all elements of the difference matrix to remove negative values. | Calculate the average of the elements in the resulting matrix. | . The result is a single number, known as the mean squared error (MSE). . # MSE loss def mse(t1, t2): diff = t1 - t2 return torch.sum(diff * diff) / diff.numel() . torch.sum returns the sum of all the elements in a tensor, and the .numel method returns the number of elements in a tensor. Let&#39;s compute the mean squared error for the current predictions of our model. . # Compute loss loss = mse(preds, targets) print(loss) . tensor(24742.8535, grad_fn=&lt;DivBackward0&gt;) . Here’s how we can interpret the result: On average, each element in the prediction differs from the actual target by about 145 (square root of the loss 24742). And that’s pretty bad, considering the numbers we are trying to predict are themselves in the range 50–200. Also, the result is called the loss, because it indicates how bad the model is at predicting the target variables. Lower the loss, better the model. . Compute gradients . With PyTorch, we can automatically compute the gradient or derivative of the loss w.r.t. to the weights and biases, because they have requires_grad set to True. . # Compute gradients loss.backward() . The gradients are stored in the .grad property of the respective tensors. Note that the derivative of the loss w.r.t. the weights matrix is itself a matrix, with the same dimensions. . # Gradients for weights print(w) print(w.grad) . tensor([[ 0.0991, 0.9799, -0.9378], [-0.4636, -0.4386, -0.7802]], requires_grad=True) tensor([[ -2831.5396, -3404.4133, -2188.0879], [-17654.8008, -19703.6074, -12104.4150]]) . The loss is a quadratic function of our weights and biases, and our objective is to find the set of weights where the loss is the lowest. If we plot a graph of the loss w.r.t any individual weight or bias element, it will look like the figure shown below. A key insight from calculus is that the gradient indicates the rate of change of the loss, or the slope of the loss function w.r.t. the weights and biases. . If a gradient element is positive: . increasing the element&#39;s value slightly will increase the loss. | decreasing the element&#39;s value slightly will decrease the loss | . . If a gradient element is negative: . increasing the element&#39;s value slightly will decrease the loss. | decreasing the element&#39;s value slightly will increase the loss. | . . The increase or decrease in loss by changing a weight element is proportional to the value of the gradient of the loss w.r.t. that element. This forms the basis for the optimization algorithm that we&#39;ll use to improve our model. . Before we proceed, we reset the gradients to zero by calling .zero_() method. We need to do this, because PyTorch accumulates, gradients i.e. the next time we call .backward on the loss, the new gradient values will get added to the existing gradient values, which may lead to unexpected results. . w.grad.zero_() b.grad.zero_() print(w.grad) print(b.grad) . tensor([[0., 0., 0.], [0., 0., 0.]]) tensor([0., 0.]) . Adjust weights and biases using gradient&#160;descent . We&#39;ll reduce the loss and improve our model using the gradient descent optimization algorithm, which has the following steps: . Generate predictions . | Calculate the loss . | Compute gradients w.r.t the weights and biases . | Adjust the weights by subtracting a small quantity proportional to the gradient . | Reset the gradients to zero . | Let&#39;s implement the above step by step. . # Generate predictions preds = model(inputs) print(preds) . tensor([[ 31.9884, -97.5489], [ 34.6570, -131.4889], [ 84.9622, -145.1297], [ 16.9713, -95.7842], [ 34.6894, -129.4807]], grad_fn=&lt;AddBackward0&gt;) . Note that the predictions are same as before, since we haven&#39;t made any changes to our model. The same holds true for the loss and gradients. . # Calculate the loss loss = mse(preds, targets) print(loss) . tensor(24742.8535, grad_fn=&lt;DivBackward0&gt;) . # Compute gradients loss.backward() print(w.grad) print(b.grad) . tensor([[ -2831.5396, -3404.4133, -2188.0879], [-17654.8008, -19703.6074, -12104.4150]]) tensor([ -35.5463, -211.8865]) . Finally, we update the weights and biases using the gradients computed above. . # Adjust weights &amp; reset gradients with torch.no_grad(): w -= w.grad * 1e-5 b -= b.grad * 1e-5 w.grad.zero_() b.grad.zero_() . A few things to note above: . We use torch.no_grad to indicate to PyTorch that we shouldn&#39;t track, calculate or modify gradients while updating the weights and biases.  . | We multiply the gradients with a really small number (10^-5 in this case), to ensure that we don&#39;t modify the weights by a really large amount, since we only want to take a small step in the downhill direction of the gradient. This number is called the learning rate of the algorithm.  . | After we have updated the weights, we reset the gradients back to zero, to avoid affecting any future computations. . | . Let&#39;s take a look at the new weights and biases. . print(w) print(b) . tensor([[ 0.1274, 1.0139, -0.9159], [-0.2870, -0.2416, -0.6592]], requires_grad=True) tensor([-0.5748, -0.7691], requires_grad=True) . With the new weights and biases, the model should have lower loss. . # Calculate loss preds = model(inputs) loss = mse(preds, targets) print(loss) . tensor(16813.5664, grad_fn=&lt;DivBackward0&gt;) . We have already achieved a significant reduction in the loss, simply by adjusting the weights and biases slightly using gradient descent. . Train for multiple&#160;epochs . To reduce the loss further, we can repeat the process of adjusting the weights and biases using the gradients multiple times. Each iteration is called an epoch. Let&#39;s train the model for 100 epochs. . # Train for 100 epochs for i in range(100): preds = model(inputs) loss = mse(preds, targets) loss.backward() with torch.no_grad(): w -= w.grad * 1e-5 b -= b.grad * 1e-5 w.grad.zero_() b.grad.zero_() . Once again, let&#39;s verify that the loss is now lower: . # Calculate loss preds = model(inputs) loss = mse(preds, targets) print(loss) . tensor(219.8388, grad_fn=&lt;DivBackward0&gt;) . As you can see, the loss is now much lower than what we started out with. Let&#39;s look at the model&#39;s predictions and compare them with the targets. . # Predictions preds . tensor([[ 59.9863, 74.3278], [ 73.4394, 96.7516], [134.0960, 135.4074], [ 36.9610, 60.4441], [ 77.2880, 98.4986]], grad_fn=&lt;AddBackward0&gt;) . # Targets targets . tensor([[ 56., 70.], [ 81., 101.], [119., 133.], [ 22., 37.], [103., 119.]]) . The prediction are now quite close to the target variables, and we can get even better results by training for a few more epochs. . Linear regression using PyTorch built-ins . The model and training process above were implemented using basic matrix operations. But since this such a common pattern , PyTorch has several built-in functions and classes to make it easy to create and train models. . Let&#39;s begin by importing the torch.nn package from PyTorch, which contains utility classes for building neural networks. . import torch.nn as nn . As before, we represent the inputs and targets and matrices. . # Input (temp, rainfall, humidity) inputs = np.array([[73, 67, 43], [91, 88, 64], [87, 134, 58], [102, 43, 37], [69, 96, 70], [73, 67, 43], [91, 88, 64], [87, 134, 58], [102, 43, 37], [69, 96, 70], [73, 67, 43], [91, 88, 64], [87, 134, 58], [102, 43, 37], [69, 96, 70]], dtype=&#39;float32&#39;) # Targets (apples, oranges) targets = np.array([[56, 70], [81, 101], [119, 133], [22, 37], [103, 119], [56, 70], [81, 101], [119, 133], [22, 37], [103, 119], [56, 70], [81, 101], [119, 133], [22, 37], [103, 119]], dtype=&#39;float32&#39;) inputs = torch.from_numpy(inputs) targets = torch.from_numpy(targets) . inputs . tensor([[ 73., 67., 43.], [ 91., 88., 64.], [ 87., 134., 58.], [102., 43., 37.], [ 69., 96., 70.], [ 73., 67., 43.], [ 91., 88., 64.], [ 87., 134., 58.], [102., 43., 37.], [ 69., 96., 70.], [ 73., 67., 43.], [ 91., 88., 64.], [ 87., 134., 58.], [102., 43., 37.], [ 69., 96., 70.]]) . We are using 15 training examples this time, to illustrate how to work with large datasets in small batches. . Dataset and DataLoader . We&#39;ll create a TensorDataset, which allows access to rows from inputs and targets as tuples, and provides standard APIs for working with many different types of datasets in PyTorch. . from torch.utils.data import TensorDataset . # Define dataset train_ds = TensorDataset(inputs, targets) train_ds[0:3] . (tensor([[ 73., 67., 43.], [ 91., 88., 64.], [ 87., 134., 58.]]), tensor([[ 56., 70.], [ 81., 101.], [119., 133.]])) . The TensorDataset allows us to access a small section of the training data using the array indexing notation ([0:3] in the above code). It returns a tuple (or pair), in which the first element contains the input variables for the selected rows, and the second contains the targets. . We&#39;ll also create a DataLoader, which can split the data into batches of a predefined size while training. It also provides other utilities like shuffling and random sampling of the data. . from torch.utils.data import DataLoader . # Define data loader batch_size = 5 train_dl = DataLoader(train_ds, batch_size, shuffle=True) . The data loader is typically used in a for-in loop. Let&#39;s look at an example. . for xb, yb in train_dl: print(xb) print(yb) break . tensor([[ 91., 88., 64.], [ 73., 67., 43.], [ 69., 96., 70.], [ 87., 134., 58.], [ 69., 96., 70.]]) tensor([[ 81., 101.], [ 56., 70.], [103., 119.], [119., 133.], [103., 119.]]) . In each iteration, the data loader returns one batch of data, with the given batch size. If shuffle is set to True, it shuffles the training data before creating batches. Shuffling helps randomize the input to the optimization algorithm, which can lead to faster reduction in the loss. . nn.Linear . Instead of initializing the weights &amp; biases manually, we can define the model using the nn.Linear class from PyTorch, which does it automatically. . # Define model model = nn.Linear(3, 2) print(model.weight) print(model.bias) . Parameter containing: tensor([[ 0.4430, -0.4030, -0.5242], [ 0.4627, 0.0753, 0.4662]], requires_grad=True) Parameter containing: tensor([0.5011, 0.1109], requires_grad=True) . PyTorch models also have a helpful .parameters method, which returns a list containing all the weights and bias matrices present in the model. For our linear regression model, we have one weight matrix and one bias matrix. . # Parameters list(model.parameters()) . [Parameter containing: tensor([[ 0.4430, -0.4030, -0.5242], [ 0.4627, 0.0753, 0.4662]], requires_grad=True), Parameter containing: tensor([0.5011, 0.1109], requires_grad=True)] . We can use the model to generate predictions in the exact same way as before: . # Generate predictions preds = model(inputs) preds . tensor([[-16.7046, 58.9756], [-28.2028, 78.6743], [-45.3696, 77.4884], [ 8.9606, 67.7903], [-44.3184, 71.8943], [-16.7046, 58.9756], [-28.2028, 78.6743], [-45.3696, 77.4884], [ 8.9606, 67.7903], [-44.3184, 71.8943], [-16.7046, 58.9756], [-28.2028, 78.6743], [-45.3696, 77.4884], [ 8.9606, 67.7903], [-44.3184, 71.8943]], grad_fn=&lt;AddmmBackward&gt;) . Loss Function . Instead of defining a loss function manually, we can use the built-in loss function mse_loss. . # Import nn.functional import torch.nn.functional as F . The nn.functional package contains many useful loss functions and several other utilities. . # Define loss function loss_fn = F.mse_loss . Let&#39;s compute the loss for the current predictions of our model. . loss = loss_fn(model(inputs), targets) print(loss) . tensor(7296.9834, grad_fn=&lt;MseLossBackward&gt;) . Optimizer . Instead of manually manipulating the model&#39;s weights &amp; biases using gradients, we can use the optimizer optim.SGD. SGD stands for stochastic gradient descent. It is called stochastic because samples are selected in batches (often with random shuffling) instead of as a single group. . # Define optimizer opt = torch.optim.SGD(model.parameters(), lr=1e-5) . Note that model.parameters() is passed as an argument to optim.SGD, so that the optimizer knows which matrices should be modified during the update step. Also, we can specify a learning rate which controls the amount by which the parameters are modified. . Train the model . We are now ready to train the model. We&#39;ll follow the exact same process to implement gradient descent: . Generate predictions . | Calculate the loss . | Compute gradients w.r.t the weights and biases . | Adjust the weights by subtracting a small quantity proportional to the gradient . | Reset the gradients to zero . | The only change is that we&#39;ll work batches of data, instead of processing the entire training data in every iteration. Let&#39;s define a utility function fit which trains the model for a given number of epochs. . # Utility function to train the model def fit(num_epochs, model, loss_fn, opt, train_dl): # Repeat for given number of epochs for epoch in range(num_epochs): # Train with batches of data for xb,yb in train_dl: # 1. Generate predictions pred = model(xb) # 2. Calculate loss loss = loss_fn(pred, yb) # 3. Compute gradients loss.backward() # 4. Update parameters using gradients opt.step() # 5. Reset the gradients to zero opt.zero_grad() # Print the progress if (epoch+1) % 10 == 0: print(&#39;Epoch [{}/{}], Loss: {:.4f}&#39;.format(epoch+1, num_epochs, loss.item())) . Some things to note above: . We use the data loader defined earlier to get batches of data for every iteration. . | Instead of updating parameters (weights and biases) manually, we use opt.step to perform the update, and opt.zero_grad to reset the gradients to zero. . | We&#39;ve also added a log statement which prints the loss from the last batch of data for every 10th epoch, to track the progress of training. loss.item returns the actual value stored in the loss tensor. . | . Let&#39;s train the model for 100 epochs. . fit(100, model, loss_fn, opt, train_dl) . Epoch [10/100], Loss: 866.8568 Epoch [20/100], Loss: 563.1091 Epoch [30/100], Loss: 316.7956 Epoch [40/100], Loss: 128.2728 Epoch [50/100], Loss: 305.4437 Epoch [60/100], Loss: 185.6665 Epoch [70/100], Loss: 101.3508 Epoch [80/100], Loss: 36.5605 Epoch [90/100], Loss: 84.5572 Epoch [100/100], Loss: 54.1609 . Let&#39;s generate predictions using our model and verify that they&#39;re close to our targets. . # Generate predictions preds = model(inputs) preds . tensor([[ 59.5274, 71.7325], [ 79.2080, 99.9687], [121.6579, 132.1071], [ 33.9094, 45.1424], [ 89.3203, 113.2075], [ 59.5274, 71.7325], [ 79.2080, 99.9687], [121.6579, 132.1071], [ 33.9094, 45.1424], [ 89.3203, 113.2075], [ 59.5274, 71.7325], [ 79.2080, 99.9687], [121.6579, 132.1071], [ 33.9094, 45.1424], [ 89.3203, 113.2075]], grad_fn=&lt;AddmmBackward&gt;) . # Compare with targets targets . tensor([[ 56., 70.], [ 81., 101.], [119., 133.], [ 22., 37.], [103., 119.], [ 56., 70.], [ 81., 101.], [119., 133.], [ 22., 37.], [103., 119.], [ 56., 70.], [ 81., 101.], [119., 133.], [ 22., 37.], [103., 119.]]) . Indeed, the predictions are quite close to our targets, and now we have a fairly good model to predict crop yields for apples and oranges by looking at the average temperature, rainfall and humidity in a region. . Reference / Credits : . This is the lecture material from the online course taught on Youtube - Link .",
            "url": "https://mlblog.singhsarbjit.com/2020/06/16/linear_regression_pytorch.html",
            "relUrl": "/2020/06/16/linear_regression_pytorch.html",
            "date": " • Jun 16, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Basic introduction to Pytorch",
            "content": "What is Pytorch? . Pytorch is an open-source machine learning library developed by Facebook. It allows flexibility and speed for scientific computing for deep learning. Consider it as a replacement of Numpy so that the GPU capability can be used. . Tensors? . Tensor is the core element of Pytorch and are basically a n-dimensional data container much like Numpy&#39;s n-dimensional array. A tensor could be a number, vector, matrix or a n-dimensional array. . import torch # Scalar - Integer t1 = torch.tensor(5) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t1, t1.shape, t1.dtype)) . Tensor is 5 with shape torch.Size([]) and data type torch.int64 . # Scalar - Float t2 = torch.tensor(5.) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t2, t2.shape, t2.dtype)) . Tensor is 5.0 with shape torch.Size([]) and data type torch.float32 . # Vector t3 = torch.tensor([1., 2, 3]) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t3, t3.shape, t3.dtype)) t4 = torch.tensor([1, 2, 3]) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t4, t4.shape, t4.dtype)) . Tensor is tensor([1., 2., 3.]) with shape torch.Size([3]) and data type torch.float32 Tensor is tensor([1, 2, 3]) with shape torch.Size([3]) and data type torch.int64 . # Matrix t5 = torch.tensor([[1., 2, 3],[4, 5, 6]]) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t5, t5.shape, t5.dtype)) t6 = torch.tensor([[1, 2, 3],[4, 5, 6]]) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t6, t6.shape, t6.dtype)) . Tensor is tensor([[1., 2., 3.], [4., 5., 6.]]) with shape torch.Size([2, 3]) and data type torch.float32 Tensor is tensor([[1, 2, 3], [4, 5, 6]]) with shape torch.Size([2, 3]) and data type torch.int64 . Creating tensors using torch.Tensor &amp; torch.tensor : . torch.Tensor is the main Tensor class and everything is an instance of it. You can use it to create an empty tensor which is not possible with torch.tensor. . # Creating tensors using torch.Tensor class # Create a tensor with 3 elements and random data t7 = torch.Tensor(3) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t7, t7.shape, t7.dtype)) # Matrix - 2X3 with random data t8 = torch.Tensor(2, 3) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t8, t8.shape, t8.dtype)) # 2X3 Matrix with data t9 = torch.Tensor([[1, 2], [3, 4]]) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t9, t9.shape, t9.dtype)) . Tensor is tensor([9.8755e-35, 1.4013e-45, 1.3633e-41]) with shape torch.Size([3]) and data type torch.float32 Tensor is tensor([[ 0.0000e+00, -2.0000e+00, 0.0000e+00], [-2.0000e+00, 8.4078e-45, -2.0000e+00]]) with shape torch.Size([2, 3]) and data type torch.float32 Tensor is tensor([[1., 2.], [3., 4.]]) with shape torch.Size([2, 2]) and data type torch.float32 . # Arithemetic operations a = torch.tensor(1) b = torch.tensor(2) c = torch.tensor(3) y = a + b + c print(y) # Derivatives a = torch.tensor(1.) b = torch.tensor(2., requires_grad=True) c = torch.tensor(3., requires_grad=True) y = a + b + c print(y) . tensor(6) tensor(6., grad_fn=&lt;AddBackward0&gt;) . Pytorch allows you to not only run the tensors in CPU but also in GPU for speed. Also, it got some unique features to track operations applied on them by forming backward graph for the tensors having requires_grad property set to True. . So basically, you can calculate the derivative of the &quot;y&quot; with respect to the other tensors having requires_grad by calling .backward method. Derivative is stored in a variable .grad associated with each tensor. . y.backward() print(&#39;dy/da:&#39;, a.grad) print(&#39;dy/db:&#39;, b.grad) print(&#39;dy/dc:&#39;, c.grad) . dy/da: None dy/db: tensor(1.) dy/dc: tensor(1.) . Numpy and Pytorch . We can quickly create tensors from Numpy arrays. . import numpy as np # Convert Numpy array to tensor a1 = np.array([[1, 2, 4.], [5, 6, 7]]) t = torch.from_numpy(a1) print(&quot;Tensor is {} with shape {} and data type {}&quot;.format(t, t.shape, t.dtype)) . Tensor is tensor([[1., 2., 4.], [5., 6., 7.]], dtype=torch.float64) with shape torch.Size([2, 3]) and data type torch.float64 . # Convert tensor to Numpy array a2 = t.numpy() print(a2) . [[1. 2. 4.] [5. 6. 7.]] .",
            "url": "https://mlblog.singhsarbjit.com/deep_learning/2020/06/09/Basic_Introduction_to_Pytorch.html",
            "relUrl": "/deep_learning/2020/06/09/Basic_Introduction_to_Pytorch.html",
            "date": " • Jun 9, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Evaluation metrics for Linear Regression",
            "content": "Assume we have following set of data . X Y . 20 | 23 | . 21 | 21 | . 22 | 26 | . 23 | 22 | . 24 | 25 | . 25 | 24 | . For this data, we get this linear regression using this calculator . y = 15.14 + 0.37x . We can solve this equation and get the value of $ hat y$ . X Y $ hat Y$ . 20 | 23 | 22.54 | . 21 | 21 | 22.91 | . 22 | 26 | 23.28 | . 23 | 22 | 23.65 | . 24 | 25 | 24.02 | . 25 | 24 | 24.39 | . We can evaluate this regression line in terms of different error metrics :- . MAE (Mean Absolute Error) :- . $$MAE = ( frac{1}{n}) sum_{i=1}^{n} left | y_{i} - hat y_{i} right |$$ . where y = actual value in the data set ; $ hat y$ = value computed by solving the regression equation . Calculate the difference between Y and $ hat Y$ | Get the absolute values | Take the mean/average i.e. divide by number of elements | X = [20, 21, 22, 23, 24, 25] Y = [23, 21, 26, 22, 25, 24] Y_BAR = [22.54, 22.91, 23.28, 23.65, 24.02, 24.39] # Core Python n = len(X) # Use length of either X or Y to get number of elements s = 0 for i in range(0,n): s += abs(Y[i] - Y_BAR[i]) MAE = s/n print (&quot;MAE using Python: %&quot;, MAE) # Using Scikit-Learn Library from sklearn.metrics import mean_absolute_error MAE_sci = mean_absolute_error(Y, Y_BAR) print (&quot;MAE using Sklearn: % &quot;, MAE_sci) # Using Numpy import numpy as np MAE_numpy = np.mean(np.abs(np.subtract(Y,Y_BAR))) print (&quot;MAE using Numpy: % &quot;, MAE_numpy) . MAE using Python: % 1.3516666666666666 MAE using Sklearn: % 1.3516666666666666 MAE using Numpy: % 1.3516666666666666 . MSE (Mean Square Error) :- . $$MSE = ( frac{1}{n}) sum_{i=1}^{n} left ( y_{i} - hat y_{i} right )^2$$ . where y = actual value in the data set ; $ hat y$ = value computed by solving the regression equation . Calculate the difference between Y and $ hat Y$ | Take a square | Take the mean/average i.e. divide by number of elements | X = [20, 21, 22, 23, 24, 25] Y = [23, 21, 26, 22, 25, 24] Y_BAR = [22.54, 22.91, 23.28, 23.65, 24.02, 24.39] # Core Python n = len(X) # Use length of either X or Y to get number of elements s = 0 for i in range(0,n): s += (Y[i] - Y_BAR[i])**2 MSE = s/n print (&quot;MSE using Python: %&quot;, MSE) # Using Scikit-Learn Library from sklearn.metrics import mean_squared_error MSE_sci = mean_squared_error(Y, Y_BAR) print (&quot;MSE using Sklearn: % &quot;, MSE_sci) # Using Numpy import numpy as np MSE_numpy = np.mean(np.square(np.subtract(Y,Y_BAR))) print (&quot;MSE using Numpy: % &quot;, MSE_numpy) . MSE using Python: % 2.5155166666666653 MSE using Sklearn: % 2.5155166666666653 MSE using Numpy: % 2.5155166666666653 . RMSE (Root Mean Square Error) :- . $$RMSE = sqrt{( frac{1}{n}) sum_{i=1}^{n} left ( y_{i} - hat y_{i} right )^2}$$ . where y = actual value in the data set ; $ hat y$ = value computed by solving the regression equation . Calculate the difference between Y and $ hat Y$ | Take a square | Take the mean/average i.e. divide by number of elements | Take the square root | X = [20, 21, 22, 23, 24, 25] Y = [23, 21, 26, 22, 25, 24] Y_BAR = [22.54, 22.91, 23.28, 23.65, 24.02, 24.39] # Core Python from math import sqrt n = len(X) # Use length of either X or Y to get number of elements s = 0 for i in range(0,n): s += (Y[i] - Y_BAR[i])**2 RMSE = sqrt(s/n) print (&quot;RMSE using Python: %&quot;, RMSE) # Using Scikit-Learn Library from sklearn.metrics import mean_squared_error RMSE_sci = sqrt(mean_squared_error(Y, Y_BAR)) print (&quot;RMSE using Sklearn: % &quot;, RMSE_sci) # Using Numpy import numpy as np RMSE_numpy = np.sqrt(np.mean(np.square(np.subtract(Y,Y_BAR)))) print (&quot;RMSE using Numpy: % &quot;, RMSE_numpy) . RMSE using Python: % 1.5860380407375685 RMSE using Sklearn: % 1.5860380407375685 RMSE using Numpy: % 1.5860380407375685 . RAE (Relative Absolute Error) :- . $$RAE = frac{ sum_{i=1}^{n} left | y_{i} - hat y_{i} right |}{ sum_{i=1}^{n} left | y_{i} - bar y right |}$$ . where y = actual value in the data set ; $ hat y$ = value computed by solving the regression equation ; $ bar y$ is mean value of y . Calculate the difference between Y and $ hat Y$ for each row, take absolute value and sum it all | Calculate the mean of Y denoted by $ bar Y$ | Calculate the difference between Y and $ bar Y$ for each row, take absolute value and sum it all | Divide value obtained in step1 by step3 | X = [20, 21, 22, 23, 24, 25] Y = [23, 21, 26, 22, 25, 24] Y_BAR = [22.54, 22.91, 23.28, 23.65, 24.02, 24.39] # Using Numpy import numpy as np RAE_numpy = np.sum(np.abs(np.subtract(Y,Y_BAR))) / np.sum(np.abs(np.subtract(Y, np.mean(Y)))) print (&quot;RAE using Numpy: % &quot;, RAE_numpy) . RAE using Numpy: % 0.9011111111111111 . RSE (Relative Squared Error) :- . $$RSE = frac{ sum_{i=1}^{n} left ( y_{i} - hat y_{i} right )^2}{ sum_{i=1}^{n} left ( y_{i} - bar y right )^2}$$ . where y = actual value in the data set ; $ hat y$ = value computed by solving the regression equation ; $ bar y$ is mean value of y . Calculate the difference between Y and $ hat Y$ for each row, square it and sum it all | Calculate the mean of Y denoted by $ bar Y$ | Calculate the difference between Y and $ bar Y$ for each row, square it and sum it all | Divide value obtained in step1 by step3 | X = [20, 21, 22, 23, 24, 25] Y = [23, 21, 26, 22, 25, 24] Y_BAR = [22.54, 22.91, 23.28, 23.65, 24.02, 24.39] # Using Numpy import numpy as np RSE_numpy = np.sum(np.square(np.subtract(Y,Y_BAR))) / np.sum(np.square(np.subtract(Y, np.mean(Y)))) print (&quot;RSE using Numpy: % &quot;, RSE_numpy) . RSE using Numpy: % 0.8624628571428568 .",
            "url": "https://mlblog.singhsarbjit.com/machine_learning/2020/05/30/model_evaluation_metrics.html",
            "relUrl": "/machine_learning/2020/05/30/model_evaluation_metrics.html",
            "date": " • May 30, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Numpy Tutorial",
            "content": "Need for Numpy : . If we have two lists and simply want to add the elements, we would have to iterate over each element of both lists and add them. Just using &quot;+&quot; operator will concatenate the lists. . a = [1, 2, 3, 4] b = [5, 6, 7, 8] print (a+b) . [1, 2, 3, 4, 5, 6, 7, 8] . r = [] for x,y in zip(a,b): r.append(x+y) print (r) . [6, 8, 10, 12] . Numpy : . import numpy as np . # Array Creation #New Arrays can be created by using array function. #This function takes list as an argument and create N-Dimensional array based on the arguments. # One Dimensional Array ar1 = np.array([1,2,3]) # Two Dimensional Array ar2 = np.array([[1,2,3], [4,5,6]]) # Other methods to create new Arrays # There are several other ways to create Arrays :- # arange([start], [stop], [step]) # This is similar to Python range function and creates evenly spaced arrays. np.arange(5) # OUT : array([0, 1, 2, 3, 4]) np.arange(2,10,2) # Excludes the stop position element # OUT : array([2, 4, 6, 8]) # linspace([start], [stop], [num]) # Creates array by number of points. np.linspace(0,6,3) # Creates 3 evenly spaced elements between start and stop point. # Note, stop point value is included. # OUT : array([0., 3., 6.]) np.linspace(0,6,3,endpoint=False) # Excludes the stop position element #OUT : array([0., 2., 4.]) . array([0., 2., 4.]) . # Type of array a = np.array([1, 2, 3, 4, 5]) type(a) . numpy.ndarray . # Data-type : Every element inside this array will be of this type a.dtype . dtype(&#39;int64&#39;) . # Another array with floating members f = np.array([1.2, 33.5, 6.4, 7.8, 8.6]) f.dtype . dtype(&#39;float64&#39;) . a[0] = 10 a . array([10, 2, 3, 4, 5]) . # Decimal portion will be truncated because all elements has to be of same type a[0] = 6.88 a . array([6, 2, 3, 4, 5]) . # Number of dimension a.ndim . 1 . # Returns a tuple showing number of elements across each dimension a.shape . (5,) . # Total number of elements a.size . 5 . # Bytes per element print(a.itemsize) print(f.itemsize) . 8 8 . # Bytes used by data portion of array a.nbytes . 40 . # Multi-Dimensional Arrays # A 2-D array is basically a list of list # A 3-D array will be a list of list of list a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]]) print(&quot;Array is : n&quot;,a) print(&quot; n&quot;) print(&quot;Size is : &quot;,a.size) print(&quot;Dimension is : &quot;,a.ndim) print(&quot;Shape is : &quot;,a.shape) # NOTE : # Dimension 0 is row, dimension 1 is column. So, in this case, we have a tuple (2,4) indicating 2 rows and # 4 elements in each row . Array is : [[1 2 3 4] [5 6 7 8]] Size is : 8 Dimension is : 2 Shape is : (2, 4) . Following picture illustartes the dimension/axis for multi-dimensional array :- . . Source : http://physics.cornell.edu/ . # Retrieving/Setting individual element from a 2-D array :- # Syntax : Array[row,column] print(&quot;Element in first row and fourth column is &quot;,a[0,3]) print(&quot;Element in second row and first column is &quot;,a[1,0]) # Retrieving all elements of a row :- # If you specify only first parameter (row index), then all elements of that row are returned print(&quot;Elements in second row&quot;, a[1]) # Setting an element a[1,0] = 10 print(&quot;Array after changing first element of second row : n&quot;, a) a[1] = [10, 11 ,12 ,13] print(&quot;Array after changing second row : n&quot;, a) . Element in first row and fourth column is 4 Element in second row and first column is 5 Elements in second row [5 6 7 8] Array after changing first element of second row : [[ 1 2 3 4] [10 6 7 8]] Array after changing second row : [[ 1 2 3 4] [10 11 12 13]] . Array Slicing :- . An array is sliced with the following syntax, which extracts the sequence based on lower and upper bound . Array[start:stop:step] . Note, that the lower (start) bound element is included but the upper(stop) bound element is not included. Step value defines the stride. . Just like Python lists, the array is represented with indices from both directions. Sequence can be extracted with the above syntax and combinations of positive/negative indices. . NOTE : If boundaries are ommited, it is considered as starting (or ending) of a list. . a = np.array([10, 11, 12, 13, 14, 15]) &quot;&quot;&quot; +++++++ | 10| 11| 12| 13| 14| 15| +++++++ 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 &quot;&quot;&quot; # Extract the second, third and fourth element print(&quot;Second, third and fourth element : a[1:4] :-&quot;, a[1:4]) print(&quot; nSame elements can be extracted with following notations as well ...&quot;) print(&quot;a[-5:-2] :- &quot;, a[-5:-2]) print(&quot;a[-5:4] :- &quot;, a[-5:4]) print(&quot;a[1:-2] :- &quot;, a[1:-2]) # Extract first three elements print(&quot; nExtract first three elements ...&quot;) print(&quot;a[:3] :- &quot;, a[:3]) # Extract last three elements print(&quot; nExtract last three elements ...&quot;) print(&quot;a[-3:] :- &quot;, a[-3:]) print(&quot;a[3:] :- &quot;, a[3:]) # Extract every other element print(&quot; nExtract every other element ...&quot;) print(&quot;a[::2] :- &quot;, a[::2]) . Second, third and fourth element : a[1:4] :- [11 12 13] Same elements can be extracted with following notations as well ... a[-5:-2] :- [11 12 13] a[-5:4] :- [11 12 13] a[1:-2] :- [11 12 13] Extract first three elements ... a[:3] :- [10 11 12] Extract last three elements ... a[-3:] :- [13 14 15] a[3:] :- [13 14 15] Extract every other element ... a[::2] :- [10 12 14] . # Inserting values a[2:] = [2, 3, 4, 5] print(a) . [10 11 2 3 4 5] . # More on slicing with an example using 2-D data a = np.arange(25).reshape(5,5) print(&quot;Original Array&quot;) print(a) print(&quot; n&quot;) print(a[4]) print(&quot; n&quot;) print(a[:,1::2]) print(&quot; n&quot;) print(a[1::2,:3:2]) . Original Array [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] [20 21 22 23 24] [[ 1 3] [ 6 8] [11 13] [16 18] [21 23]] [[ 5 7] [15 17]] . a = np.array([1, 2, 3, 4, 5]) b = a[:3] b[0] = -1 print(a) . [-1 2 3 4 5] . c = a.copy() . Fancy Indexing :- . To understand this better, let&#39;s s . # Fancy Indexing - Index Based : (1-D) # To understand this better, let&#39;s say we have an array (1-D for simplicity) with some random numbers a = np.random.randint(1, 100, 15) # Will create an array of 15 elements between 1 &amp; 100 print (a) # Now, say we need to extract the element(s) at index 1, 5 and 13. One way is to extract each item individually print(&quot;Element at index {} is {}&quot;.format(1, a[1])) print(&quot;Element at index {} is {}&quot;.format(5, a[5])) print(&quot;Element at index {} is {}&quot;.format(13, a[13])) # However, Numpy offers another approach where we could just a pass of list of indexes for which we want to # retrieve elements index = [1, 5, 13] print(&quot;Elements at indexes {} are {}&quot;.format(index, a[index])) . [71 21 92 4 88 21 11 72 43 33 62 17 73 32 34] Element at index 1 is 21 Element at index 5 is 21 Element at index 13 is 32 Elements at indexes [1, 5, 13] are [21 21 32] . # Fancy Indexing - Boolean Array Indexing (1-D) # Consider we have an array of odd and even numbers. # Our task is to find out even elements a = np.array([1, 3, 4, 5, 6, 8, 10, 3, 1]) # Numpy allows elements to be retrieved by a boolean array i.e. elements will be returned for True element mask = (a % 2 == 0) print(&quot;Original array is {}&quot;.format(a)) print(&quot;Mask array is {}&quot;.format(mask)) print(&quot;Even numbers are &quot;) print(a[mask]) . Original array is [ 1 3 4 5 6 8 10 3 1] Mask array is [False False True False True True True False False] Even numbers are [ 4 6 8 10] . # Fancy Indexing - Index Based : (2-D) # Fancy indexing can also be performed on a 2-D array a = np.arange(25).reshape(5,5) # If we have a 2-D array, passing a single index will return the entire row print(&quot;Original array is n {}&quot;.format(a)) print(&quot; n&quot;) print(&quot;Contents at index (or row) {} is {}&quot;.format(3,a[3])) print(&quot;Contents at index (or row) {} is {}&quot;.format(2,a[2])) . Original array is [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] Contents at index (or row) 3 is [15 16 17 18 19] Contents at index (or row) 2 is [10 11 12 13 14] . # If we pass multiple indexes (as a list), we get the data for these entire rows print(&quot;a[3,2] : This will print the element at 3rd row and 2nd column :&quot;) print(a[3,2]) print(&quot; n&quot;) print(&quot;a[[3,2]] : This will print the contents for 3rd and 2nd row :&quot;) print(a[[3,2]]) print(&quot; n&quot;) print(&quot;a[[0,2,4],[0,3,0]] : This will print elements at (0,0), (2,3) &amp; (4,0) :&quot;) print(a[[0,2,4],[0,3,0]]) print(&quot; n&quot;) print(&quot;a[[0,2,4]][:] : This will print all elements at row 0, 2 &amp; 4 :&quot;) print(a[[0,2,4]][:]) print(a[[0,2,4]]) print(&quot; n&quot;) print(&quot;a[[0,2,4]][:,[0,1,3]] : This will print elements at row 0, 2 &amp; 4 AND columns 0, 1 &amp; 3 :&quot;) print(a[[0,2,4]][:,[0,1,3]]) . a[3,2] : This will print the element at 3rd row and 2nd column : 17 a[[3,2]] : This will print the contents for 3rd and 2nd row : [[15 16 17 18 19] [10 11 12 13 14]] a[[0,2,4],[0,3,0]] : This will print elements at (0,0), (2,3) &amp; (4,0) : [ 0 13 20] a[[0,2,4]][:] : This will print all elements at row 0, 2 &amp; 4 : [[ 0 1 2 3 4] [10 11 12 13 14] [20 21 22 23 24]] [[ 0 1 2 3 4] [10 11 12 13 14] [20 21 22 23 24]] a[[0,2,4]][:,[0,1,3]] : This will print elements at row 0, 2 &amp; 4 AND columns 0, 1 &amp; 3 : [[ 0 1 3] [10 11 13] [20 21 23]] . print(a) . [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] . # Boolean Array Indexing (2-D) # Boolean Array indexing will work similar to 1-D. Let&#39;s use the similar example to find all odd elements mask = (a % 2 != 0) print(&quot;Original array is n {} n&quot;.format(a)) print(&quot;Mask array is n {} n&quot;.format(mask)) print(&quot;Odd numbers are &quot;) print(a[mask]) . Original array is [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] Mask array is [[False True False True False] [ True False True False True] [False True False True False] [ True False True False True] [False True False True False]] Odd numbers are [ 1 3 5 7 9 11 13 15 17 19 21 23] . Vectorization : . In high-level languages the term vectorization refers to use of pre-compiled, optimized code written in language like C to perform mathematical operations over sequence of data. Basically, this is done without writing &quot;for&quot; loop in Python. . Python native list allows elements to be of different data types as opposed to Numpy array where the elements have to be of same data type. This property allows mathematical operations to be delecated to pre-compiled code written in C to gain performance improvements. . a = np.arange(16).reshape(4,4) b = np.arange(16).reshape(4,4) print(&quot;Array a is n&quot;,a,&quot; n n&quot;,&quot;Array b is n&quot;,b, &quot; n&quot;) # Element wise operation print(&quot;a + 2 : Adding 2 to each element :- &quot;,&quot; n&quot;,a+2, &quot; n&quot;) print(&quot;a - 2 : Subtracting 2 from each element :- &quot;,&quot; n&quot;,a-2, &quot; n&quot;) print(&quot;a / 2 : Dividing 2 from each element :- &quot;,&quot; n&quot;,a/2, &quot; n&quot;) print(&quot;a * 2 : Multiplying 2 from each element :- &quot;,&quot; n&quot;,a*2, &quot; n&quot;) . Array a is [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]] Array b is [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]] a + 2 : Adding 2 to each element :- [[ 2 3 4 5] [ 6 7 8 9] [10 11 12 13] [14 15 16 17]] a - 2 : Subtracting 2 from each element :- [[-2 -1 0 1] [ 2 3 4 5] [ 6 7 8 9] [10 11 12 13]] a / 2 : Dividing 2 from each element :- [[0. 0.5 1. 1.5] [2. 2.5 3. 3.5] [4. 4.5 5. 5.5] [6. 6.5 7. 7.5]] a * 2 : Multiplying 2 from each element :- [[ 0 2 4 6] [ 8 10 12 14] [16 18 20 22] [24 26 28 30]] . # Array based operations :- print(&quot;a + b : Adding each element of array &#39;a&#39; to element of &#39;b&#39; :- &quot;,&quot; n&quot;,a+b, &quot; n&quot;) print(&quot;a - b : Subtracting each element of array &#39;a&#39; to element of &#39;b&#39; :- &quot;,&quot; n&quot;,a-b, &quot; n&quot;) print(&quot;a * b : Multiplying each element of array &#39;a&#39; to element of &#39;b&#39; :- &quot;,&quot; n&quot;,a*b, &quot; n&quot;) . a + b : Adding each element of array &#39;a&#39; to element of &#39;b&#39; :- [[ 0 2 4 6] [ 8 10 12 14] [16 18 20 22] [24 26 28 30]] a - b : Subtracting each element of array &#39;a&#39; to element of &#39;b&#39; :- [[0 0 0 0] [0 0 0 0] [0 0 0 0] [0 0 0 0]] a * b : Multiplying each element of array &#39;a&#39; to element of &#39;b&#39; :- [[ 0 1 4 9] [ 16 25 36 49] [ 64 81 100 121] [144 169 196 225]] . # Sequence based operations # These functions are called usoc or universal functions which operate on each element print(np.sum(a)) # Add each element in array print(np.sum(a,axis=0)) # Add each element across axis-0 (rows) - vertical direction print(np.sum(a,axis=1)) # Add each element across axis-1 (columns) . 120 [24 28 32 36] [ 6 22 38 54] . Broadcasting :- . When we perform arithemetic operations on two arrays, the operations are performed element wise. One condition to perform such operations is that the arrays should be of same shape. . Broadcasting is a technique used by Numpy to perform operations on arrays of different shapes. . Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. [From Numpy.org] . a = np.array([1, 2, 3]) b = np.array([2, 2, 2]) print(a+b) . [3 4 5] . Example 1 :- . In the below example, we are performing operations between an array and scalar. Scalar can be considered as another array (dimensionless). If you look at the results, they are identical to the example above (where b is an 1*3 array with 2 as an element). . In this case, the smaller array (scalar) is broadcasted across the larger array i.e. the smaller array is duplicated to match the dimensions and size of larger array. . (Image Source : Numpy.org) . a = np.array([1, 2, 3]) b = 2 print(a+b) . [3 4 5] . Example 2 :- . In this example, a 1-D array is added to a 2-D array. . (Image Source : Numpy.org) . a = np.array([[0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30]]) b = np.array([[0, 1, 2]]) print(a+b) . [[ 0 1 2] [10 11 12] [20 21 22] [30 31 32]] . Broadcasting Rules :- . Rule 1: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side. . Rule 2: If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape. . Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is raised. . # Example 1 a = np.ones((2,4)) b = np.arange(4) print(&quot;Array a is :-&quot;) print(a) print(&quot; nArray b is :-&quot;) print(b) print(&quot; nShape of array a is :-&quot;) print(a.shape) # =&gt; (2,4) print(&quot; nShape of array b is :-&quot;) print(b.shape) # =&gt; (4,) # Apply rule 1 on the array with fewer dimensions i.e. pad with ones on left side # a.shape =&gt; (2,4) # b.shape =&gt; (1,4) # Apply rule 2 : Stretch the dimension for array b accross dimension with 1&#39;s # a.shape =&gt; (2,4) # b.shape =&gt; (2,4) # Apply rule 3 : Dimensions matches print(&quot; n a+b is :-&quot;) print(a+b) # View broadcasted arrays x, y = np.broadcast_arrays(a, b) print(&quot; nArray a after broadcasting is (before addition) :-&quot;) print(x) print(&quot; nArray b after broadcasting is (before addition) :-&quot;) print(y) . Array a is :- [[1. 1. 1. 1.] [1. 1. 1. 1.]] Array b is :- [0 1 2 3] Shape of array a is :- (2, 4) Shape of array b is :- (4,) a+b is :- [[1. 2. 3. 4.] [1. 2. 3. 4.]] Array a after broadcasting is (before addition) :- [[1. 1. 1. 1.] [1. 1. 1. 1.]] Array b after broadcasting is (before addition) :- [[0 1 2 3] [0 1 2 3]] . # Example 2 a = np.arange(4).reshape(4,1) b = np.arange(4) print(&quot;Array a is :-&quot;) print(a) print(&quot; nArray b is :-&quot;) print(b) print(&quot; nShape of array a is :-&quot;) print(a.shape) # =&gt; (4,1) print(&quot; nShape of array b is :-&quot;) print(b.shape) # =&gt; (4,) # Apply rule 1 on the array with fewer dimensions i.e. pad with ones on left side # a.shape =&gt; (4,1) # b.shape =&gt; (1,4) # Apply rule 2 : Stretch the dimension for array b accross dimension with 1&#39;s # a.shape =&gt; (4,4) # b.shape =&gt; (4,4) # Apply rule 3 : Dimensions matches print(&quot; n a+b is :-&quot;) print(a+b) # View broadcasted arrays x, y = np.broadcast_arrays(a, b) print(&quot; nArray a after broadcasting is (before addition) :-&quot;) print(x) print(&quot; nArray b after broadcasting is (before addition) :-&quot;) print(y) . Array a is :- [[0] [1] [2] [3]] Array b is :- [0 1 2 3] Shape of array a is :- (4, 1) Shape of array b is :- (4,) a+b is :- [[0 1 2 3] [1 2 3 4] [2 3 4 5] [3 4 5 6]] Array a after broadcasting is (before addition) :- [[0 0 0 0] [1 1 1 1] [2 2 2 2] [3 3 3 3]] Array b after broadcasting is (before addition) :- [[0 1 2 3] [0 1 2 3] [0 1 2 3] [0 1 2 3]] . # Example 3 a = np.ones((4,3)) b = np.arange(4) print(&quot;Array a is :-&quot;) print(a) print(&quot; nArray b is :-&quot;) print(b) print(&quot; nShape of array a is :-&quot;) print(a.shape) # =&gt; (4,3) print(&quot; nShape of array b is :-&quot;) print(b.shape) # =&gt; (4,) # Apply rule 1 on the array with fewer dimensions i.e. pad with ones on left side # a.shape =&gt; (4,3) # b.shape =&gt; (1,4) # Apply rule 2 : Stretch the dimension for array b accross dimension with 1&#39;s # a.shape =&gt; (4,3) # b.shape =&gt; (4,4) # Apply rule 3 : Dimensions DOES NOT matches print(&quot; n a+b is :-&quot;) #print(a+b) # View broadcasted arrays try: x, y = np.broadcast_arrays(a, b) print(&quot; nArray a after broadcasting is (before addition) :-&quot;) print(x) print(&quot; nArray b after broadcasting is (before addition) :-&quot;) print(y) except Exception as e: print(e) . Array a is :- [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] Array b is :- [0 1 2 3] Shape of array a is :- (4, 3) Shape of array b is :- (4,) a+b is :- shape mismatch: objects cannot be broadcast to a single shape . Shape Operations . reshape(array, newshape) . Takes an array as an argument with newshape (integer or tuple). The newshape should be compatible with existing shape. . ravel(array) . Takes an array as an argument and returns a flattened contiguous array (1-D). . a = np.arange(6).reshape((2,3)) print(a) b = np.ravel(x) print(b) . [[0 1 2] [3 4 5]] [0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3] .",
            "url": "https://mlblog.singhsarbjit.com/tutorials/2020/05/15/numpy_tutorial.html",
            "relUrl": "/tutorials/2020/05/15/numpy_tutorial.html",
            "date": " • May 15, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Linear Regression",
            "content": "Linear Regression is one of the common and popular algorithm in Machine Learning. Infact, typically this would be the first algorithm that you will encounter while learning Machine Learning. . Linear regression as the name suggests is a model that assumes a linear relationship between independent variable (x) and the dependent or target variable (y). There are two types on Linear Regression Model :- . Simple Linear Regression : Linear model between one independent variable (x) and target variable (y). . Multiple Linear Regression : Linear model between two or more independent variables (x1, x2 ...) and target variable (y). . Linear regression model would predict the output (dependent variable) as a function of independent variable. . Y = a + b X . where, Y : Predictor Variable X : Independent Variable a : Intercept of regression line (i.e. value of Y when X=0) b : Slope of regression line (i.e. rate of change of Y when X is incremented by 1 unit) . For Multiple Linear Regression, equation would be . Y = a + b1X1 + b2X2 + b3X3 + ...... . Let&#39;s start with Linear Regression using Python. For this tutorial, I&#39;ll be using Boston Housing Price Data Set, which is provided in SciKit Learn library SciKit Link. Details about this data set can be found at Link . First import all the required libraries. . import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from scipy import stats from sklearn.datasets import load_boston . We will load the dataset using load_boston method, this will return a Bunch object. Bunch object is like a Python dictionary, let&#39;s quickly look at the significance of keys :- . data &emsp;: &emsp; Data to learn target &emsp;: &emsp; Target column, for this example Median value of owner occupied home will be the target DESCR &emsp;: &emsp; Description of dataset including the headers significance feature_names &emsp;: &emsp; Names of header filename &emsp;: &emsp; Physical location from where the data was created . boston = load_boston() . Quick Analysis of Data Set . print(&quot;Shape for Data is&quot;, boston.data.shape) print(&quot;Shape for Target is&quot;, boston.target.shape) print(&quot;Names of header : n&quot;, boston.feature_names) print(&quot;Dataset description : n&quot;, boston.DESCR) . Shape for Data is (506, 13) Shape for Target is (506,) Names of header : [&#39;CRIM&#39; &#39;ZN&#39; &#39;INDUS&#39; &#39;CHAS&#39; &#39;NOX&#39; &#39;RM&#39; &#39;AGE&#39; &#39;DIS&#39; &#39;RAD&#39; &#39;TAX&#39; &#39;PTRATIO&#39; &#39;B&#39; &#39;LSTAT&#39;] Dataset description : .. _boston_dataset: Boston house prices dataset **Data Set Characteristics:** :Number of Instances: 506 :Number of Attributes: 13 numeric/categorical predictive. Median Value (attribute 14) is usually the target. :Attribute Information (in order): - CRIM per capita crime rate by town - ZN proportion of residential land zoned for lots over 25,000 sq.ft. - INDUS proportion of non-retail business acres per town - CHAS Charles River dummy variable (= 1 if tract bounds river; 0 otherwise) - NOX nitric oxides concentration (parts per 10 million) - RM average number of rooms per dwelling - AGE proportion of owner-occupied units built prior to 1940 - DIS weighted distances to five Boston employment centres - RAD index of accessibility to radial highways - TAX full-value property-tax rate per $10,000 - PTRATIO pupil-teacher ratio by town - B 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town - LSTAT % lower status of the population - MEDV Median value of owner-occupied homes in $1000&#39;s :Missing Attribute Values: None :Creator: Harrison, D. and Rubinfeld, D.L. This is a copy of UCI ML housing dataset. https://archive.ics.uci.edu/ml/machine-learning-databases/housing/ This dataset was taken from the StatLib library which is maintained at Carnegie Mellon University. The Boston house-price data of Harrison, D. and Rubinfeld, D.L. &#39;Hedonic prices and the demand for clean air&#39;, J. Environ. Economics &amp; Management, vol.5, 81-102, 1978. Used in Belsley, Kuh &amp; Welsch, &#39;Regression diagnostics ...&#39;, Wiley, 1980. N.B. Various transformations are used in the table on pages 244-261 of the latter. The Boston house-price data has been used in many machine learning papers that address regression problems. .. topic:: References - Belsley, Kuh &amp; Welsch, &#39;Regression diagnostics: Identifying Influential Data and Sources of Collinearity&#39;, Wiley, 1980. 244-261. - Quinlan,R. (1993). Combining Instance-Based and Model-Based Learning. In Proceedings on the Tenth International Conference of Machine Learning, 236-243, University of Massachusetts, Amherst. Morgan Kaufmann. . # Create a Pandas Data Frame from this data set df = pd.DataFrame(boston.data) df.head(2) . 0 1 2 3 4 5 6 7 8 9 10 11 12 . 0 0.00632 | 18.0 | 2.31 | 0.0 | 0.538 | 6.575 | 65.2 | 4.0900 | 1.0 | 296.0 | 15.3 | 396.9 | 4.98 | . 1 0.02731 | 0.0 | 7.07 | 0.0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2.0 | 242.0 | 17.8 | 396.9 | 9.14 | . As you can see that the data frame has no header names and is also missing our target column. Let&#39;s fix this first :- . df.columns = boston.feature_names df[&#39;MEDV&#39;] = boston.target df.head(2) . CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT MEDV . 0 0.00632 | 18.0 | 2.31 | 0.0 | 0.538 | 6.575 | 65.2 | 4.0900 | 1.0 | 296.0 | 15.3 | 396.9 | 4.98 | 24.0 | . 1 0.02731 | 0.0 | 7.07 | 0.0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2.0 | 242.0 | 17.8 | 396.9 | 9.14 | 21.6 | . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 506 entries, 0 to 505 Data columns (total 14 columns): CRIM 506 non-null float64 ZN 506 non-null float64 INDUS 506 non-null float64 CHAS 506 non-null float64 NOX 506 non-null float64 RM 506 non-null float64 AGE 506 non-null float64 DIS 506 non-null float64 RAD 506 non-null float64 TAX 506 non-null float64 PTRATIO 506 non-null float64 B 506 non-null float64 LSTAT 506 non-null float64 MEDV 506 non-null float64 dtypes: float64(14) memory usage: 55.4 KB . Data Wrangling . If we check our data, it doesn&#39;t seems to have any missing value. So, we will assume this as cleaned data and will use as such. . df.isnull().sum() . CRIM 0 ZN 0 INDUS 0 CHAS 0 NOX 0 RM 0 AGE 0 DIS 0 RAD 0 TAX 0 PTRATIO 0 B 0 LSTAT 0 MEDV 0 dtype: int64 . Exploratory Data Analysis . # Descriptive Statistics df.describe() . CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT MEDV . count 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | . mean 3.613524 | 11.363636 | 11.136779 | 0.069170 | 0.554695 | 6.284634 | 68.574901 | 3.795043 | 9.549407 | 408.237154 | 18.455534 | 356.674032 | 12.653063 | 22.532806 | . std 8.601545 | 23.322453 | 6.860353 | 0.253994 | 0.115878 | 0.702617 | 28.148861 | 2.105710 | 8.707259 | 168.537116 | 2.164946 | 91.294864 | 7.141062 | 9.197104 | . min 0.006320 | 0.000000 | 0.460000 | 0.000000 | 0.385000 | 3.561000 | 2.900000 | 1.129600 | 1.000000 | 187.000000 | 12.600000 | 0.320000 | 1.730000 | 5.000000 | . 25% 0.082045 | 0.000000 | 5.190000 | 0.000000 | 0.449000 | 5.885500 | 45.025000 | 2.100175 | 4.000000 | 279.000000 | 17.400000 | 375.377500 | 6.950000 | 17.025000 | . 50% 0.256510 | 0.000000 | 9.690000 | 0.000000 | 0.538000 | 6.208500 | 77.500000 | 3.207450 | 5.000000 | 330.000000 | 19.050000 | 391.440000 | 11.360000 | 21.200000 | . 75% 3.677083 | 12.500000 | 18.100000 | 0.000000 | 0.624000 | 6.623500 | 94.075000 | 5.188425 | 24.000000 | 666.000000 | 20.200000 | 396.225000 | 16.955000 | 25.000000 | . max 88.976200 | 100.000000 | 27.740000 | 1.000000 | 0.871000 | 8.780000 | 100.000000 | 12.126500 | 24.000000 | 711.000000 | 22.000000 | 396.900000 | 37.970000 | 50.000000 | . Let&#39;s use some visualization techniques on our data to understand the distribution and relationship of independent variables with our target variable. . For distribution of data, we will use Histogram. Before proceeding, let&#39;s look at what Histogram is :- . A histogram is a type of bar graph that shows the frequency or number of values compared to a set of value ranges. To construct a histogram, the first step is to “bin” the range of values — that is, divide the entire range of values into a series of intervals — and then count how many values fall into each interval. The bins are usually specified as consecutive, non-overlapping intervals of a variable. The bins (intervals) must be adjacent, and are often (but are not required to be) of equal size. . Let&#39;s use histogram to view the data distribution in our case. Look closely at our target (MEDV) and notice that the prices are mainly in the mid range distribution. . df.hist(bins=30, figsize=(18,18)) . array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1cfa5320&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d240780&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d268be0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d29a198&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d2bf710&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d2e7ba8&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d316160&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d33c710&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d33c748&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d394208&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d3ba780&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d3e1cf8&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d4102b0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d437828&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d45eda0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d48e358&gt;]], dtype=object) . To visualize the relationship between independent variables and target variable (MEDV), we will use Regression Plot, which is basically a Scatter Plot with fitted regression line. We use regression plot for variables with continous values, while a box plot will be used for categorical variables. . plt.figure(figsize=(25, 25)) for i, col in enumerate(boston.feature_names): plt.subplot(4, 4 , i+1) sns.regplot(x=col, y=&#39;MEDV&#39;, data=df) plt.title(&quot;%s vs MEDV&quot; %(col)) . Observations so far :- . Variable &#39;RM&#39; seems to have positive linear relationship with target variable &#39;MEDV&#39;. | Variable &#39;LSTAT&#39; seems to have negative linear relationship with target variable &#39;MEDV&#39;. | . Let&#39;s use other statistical methods to confirm our observations. We will use Pearson Corelation as our statistical tool. . What is Pearson Corelation? . A Pearson Corelation is a number between -1 and 1 which indicates the extent to which two variables are linearly related. . Corelation Cofficient: . 1 - Positively correlated -1 - Negatively correlated. 0 - Not correlated. . P-value: . The P-value is the probability value that the correlation between these two variables is statistically significant. . By convention, when the . p-value is &lt; 0.001: we say there is strong evidence that the correlation is significant. the p-value is &lt; 0.05: there is moderate evidence that the correlation is significant. the p-value is &lt; 0.1: there is weak evidence that the correlation is significant. the p-value is &gt; 0.1: there is no evidence that the correlation is significant. . We will use the Pandas data frame method &quot;corr()&quot; to find the co-relation and then use the Seaborn&#39;s Heatmap to plot it. . sns.set(rc={&#39;figure.figsize&#39;:(8,8)}) sns.heatmap(df.corr().round(2), square=True, cmap=&#39;RdYlGn&#39;, annot=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a203d7b70&gt; . We observed visually that attributes &#39;RM&#39; exhibits postive linear relationship, which seems correct as per Corelation Cofficient with a value of 0.7. We also observed that &#39;LSTAT&#39; exhibits negative linear relationship with &#39;MEDV&#39; and this seems to be correct statistically as well with a cofficient value of -0.74. . Let&#39;s also look at the p-value as well. . pearson_coef1, p_value1 = stats.pearsonr(df[&#39;RM&#39;], df[&#39;MEDV&#39;]) print(&quot;The Pearson Correlation Coefficient for RM is&quot;, pearson_coef1, &quot; with a P-value of P = &quot;, p_value1) pearson_coef2, p_value2 = stats.pearsonr(df[&#39;LSTAT&#39;], df[&#39;MEDV&#39;]) print(&quot;The Pearson Correlation Coefficient for LSTAT is&quot;, pearson_coef2, &quot; with a P-value of P = &quot;, p_value2) print(&quot;Is there strong evidence if corelation is signifcant for RM :- &quot;, p_value1 &lt; 0.001) print(&quot;Is there strong evidence if corelation is signifcant for LSTAT :- &quot;, p_value2 &lt; 0.001) . The Pearson Correlation Coefficient for RM is 0.6953599470715393 with a P-value of P = 2.487228871008295e-74 The Pearson Correlation Coefficient for LSTAT is -0.7376627261740147 with a P-value of P = 5.081103394389002e-88 Is there strong evidence if corelation is signifcant for RM :- True Is there strong evidence if corelation is signifcant for LSTAT :- True . As you can notice, our corelation is significant for variables &#39;RM&#39; and &#39;LSTAT&#39;. . Linear Model Creation . Now that we have indentified few variables which appears to have linear relationship with our target data, we will start developing the Linear Regression Model. . We will start with Simple Linear Regression. As stated above, Simple Linear Regression only uses one variable, so we will use only &#39;RM&#39; attribute. . First, we will import the LinearRegression class from the SciKit library and create a LinearRegression object. Then we will train the model, find the slope and intercept and finally we will do some prediction. . NOTE : For this post as part of explaining linear regression model, I will be using the entire data set for training. In real world, we will split the data into test and training data. This will be covered in a later post. . from sklearn.linear_model import LinearRegression # Create Linear Regression Object lm1 = LinearRegression() X1 = df[[&#39;RM&#39;]] Y1 = df[[&#39;MEDV&#39;]] # Target # Fit (Train) the model lm1.fit(X1,Y1) print(&quot;Intercept for the model is&quot;, lm1.intercept_, &quot;and the scope is&quot;,lm1.coef_) # Prediction Yout1 = lm1.predict(X1) # Actual and Predicted values (first five) print(&quot;Predicted Values:&quot;,Yout1[0:5]) print(&quot;Actual Values:&quot;,Y1.values[0:5]) . Intercept for the model is [-34.67062078] and the scope is [[9.10210898]] Predicted Values: [[25.17574577] [23.77402099] [30.72803225] [29.02593787] [30.38215211]] Actual Values: [[24. ] [21.6] [34.7] [33.4] [36.2]] . Now, we will develop the Multiple Linear Regression with two variables - &#39;RM&#39; and &#39;LSTAT&#39;. . lm2 = LinearRegression() X2 = df[[&#39;RM&#39;, &#39;LSTAT&#39;]] Y2 = df[[&#39;MEDV&#39;]] # Fit (Train) the model lm2.fit(X2,Y2) print(&quot;Intercept for the model is&quot;, lm2.intercept_, &quot;and the scope is&quot;,lm2.coef_) # Prediction Yout2 = lm2.predict(X2) # Actual and Predicted values (first five) print(&quot;Predicted Values:&quot;,Yout2[0:5]) print(&quot;Actual Values:&quot;,Y2.values[0:5]) . Intercept for the model is [-1.35827281] and the scope is [[ 5.09478798 -0.64235833]] Predicted Values: [[28.94101368] [25.48420566] [32.65907477] [32.40652 ] [31.63040699]] Actual Values: [[24. ] [21.6] [34.7] [33.4] [36.2]] . Model Visualization . We will visualize our models that we have created. For Simple Linear Regression, we can either use Regression Plot or Residual Plot. In case of regression plot, we need to focus on spread of data from regression line. If the data is too far from regression line, then we can say that Linear Model is not the best fit. . Since we have already used Regression Plot, we will use Residual Plot. A Residual is the difference between observed value (Y) and predicted value (Yout). In residual plot, X-axis will have independent variable and Y-Axis will have residuals. . What to look in residual plot? . If the points in a residual plot are randomly spread out around the x-axis, then a linear model is appropriate for the data. Randomly spread out residuals means that the variance is constant, and thus the linear model is a good fit for this data. | . # Seaborn library to be used for Residual Plot plt.figure(figsize=(6,6)) sns.residplot(df[&#39;RM&#39;],df[&#39;MEDV&#39;]) plt.show() . For Multiple Linear Regression, we can&#39;t use Regression or Residual Plot because of multiple independent variables, so we will use Distribution Plot. . plt.figure(figsize=(6,6)) ax1 = sns.distplot(df[&#39;MEDV&#39;], hist=False, color=&quot;r&quot;, label=&quot;Actual&quot;) sns.distplot(Yout2, hist=False, color=&quot;b&quot;, label=&quot;Fitted&quot;, ax=ax1) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1e74a748&gt; . Model Accuracy . We will use the following quantitative methods for finding model accuracy. . Mean Squared Error (MSE) . The Mean Squared Error measures the average of the squares of errors. It is calculated by :- . Finding the error between actual and predicted value | Taking a square of it | Sum up all the values | Divide by number of values | . R-squared . R squared, also known as the coefficient of determination is a measure to indicate how close the data is to the fitted regression line. . R^2 = 1 - MSE of regression line / MSE of average of data . Which one is better model? . Model will less MSE and high R-Square value | . We can use the sklearn.metrics.mean_squared_error to find the Mean Squared Error and model score() method to obtain R-Square value. . from sklearn.metrics import mean_squared_error # Simple Linear Regression mse1 = mean_squared_error(Y1,Yout1) print(&quot;Mean square error for simple linear regression is&quot;,mse1) print(&quot;R-Square value for simple linear regression is&quot;, lm1.score(X1,Y1)) print(&quot; n&quot;) # Multiple Linear Regression mse2 = mean_squared_error(Y2,Yout2) print(&quot;Mean square error for mulitple linear regression is&quot;,mse2) print(&quot;R-Square value for multiple linear regression is&quot;, lm2.score(X2,Y2)) . Mean square error for simple linear regression is 43.60055177116956 R-Square value for simple linear regression is 0.4835254559913343 Mean square error for mulitple linear regression is 30.51246877729947 R-Square value for multiple linear regression is 0.6385616062603403 . We can see that the multiple linear regression model seems to perform better because of high R-Square value and low mean square error. . Model Evaluation : Train and Test Data, Cross Validation . As I mentioned before, in real-world we will split our data into test and training data to evaluate our model. We will use &quot;train_test_split&quot; method to split our data into testing and training data. In this section, I will be using Multiple Regression Model to illustrate this process. . # First step that we will take is to seperate target data y_data = df[&#39;MEDV&#39;] x_data = df.drop(&#39;MEDV&#39;,axis=1) from sklearn.model_selection import train_test_split # Split the data into test and training (15% as test data) x_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.15, random_state=10) print(&quot;Number of test samples :&quot;, x_test.shape[0]) print(&quot;Number of training samples:&quot;,x_train.shape[0]) lm = LinearRegression() # Fit (Train) the model using the training data lm.fit(x_train[[&#39;RM&#39;,&#39;LSTAT&#39;]],y_train) # Prediction using Training Data yout_train = lm.predict(x_train[[&#39;RM&#39;,&#39;LSTAT&#39;]]) print(yout_train[0:5]) # Prediction using Test Data yout_test = lm.predict(x_test[[&#39;RM&#39;,&#39;LSTAT&#39;]]) print(yout_test[0:5]) print(&quot; n&quot;) # Model accuracy using Test Data mse_test = mean_squared_error(y_test,yout_test) print(&quot;Mean square error is&quot;,mse_test) print(&quot;R-Square value using test data is&quot;, lm.score(x_test[[&#39;RM&#39;,&#39;LSTAT&#39;]],y_test)) print(&quot; n&quot;) # Model accuracy using Training Data mse_train = mean_squared_error(y_train,yout_train) print(&quot;Mean square error is&quot;,mse_train) print(&quot;R-Square value using training data is&quot;, lm.score(x_train[[&#39;RM&#39;,&#39;LSTAT&#39;]],y_train)) . Number of test samples : 76 Number of training samples: 430 [38.74400503 5.69000561 19.41554723 30.26876646 21.13562849] [26.21310048 29.61955969 27.50797208 29.69508151 17.77881853] Mean square error is 47.91753944668556 R-Square value using test data is 0.5784951912105682 Mean square error is 27.636206385020866 R-Square value using training data is 0.6375993387266081 . Cross Validation : . Division of data into testing and training data may result into a problem especially if the data is sorted by some particular features and our testing data does not have that data. With Cross Validation, we will use entire subset of data for training and testing in iterations. This is just a brief introduction on this topic and there are other methods to perform cross validation. . In the example below, we are using K-Fold validation technique and dividing our data into 5 folds and each of the fold will be used as a test data. We will then take the mean of all the iterations. . from sklearn.model_selection import cross_val_score, KFold rcross = cross_val_score(lm, x_data, y_data, cv=KFold(n_splits=5,shuffle=True)) print(rcross) print(&quot;The mean of the folds are&quot;, rcross.mean()) . [0.62229666 0.7348349 0.74170714 0.65677571 0.77563056] The mean of the folds are 0.7062489913934608 .",
            "url": "https://mlblog.singhsarbjit.com/machine_learning/2020/05/12/Linear_Regression.html",
            "relUrl": "/machine_learning/2020/05/12/Linear_Regression.html",
            "date": " • May 12, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://mlblog.singhsarbjit.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://mlblog.singhsarbjit.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}