{
  
    
        "post0": {
            "title": "Linear Regression",
            "content": "Linear Regression is one of the common and popular algorithm in Machine Learning. Infact, typically this would be the first algorithm that you will encounter while learning Machine Learning. . Linear regression as the name suggests is a model that assumes a linear relationship between independent variable (x) and the dependent or target variable (y). There are two types on Linear Regression Model :- . Simple Linear Regression : Linear model between one independent variable (x) and target variable (y). . Multiple Linear Regression : Linear model between two or more independent variables (x1, x2 ...) and target variable (y). . Linear regression model would predict the output (dependent variable) as a function of independent variable. . Y = a + b X . where, Y : Predictor Variable X : Independent Variable a : Intercept of regression line (i.e. value of Y when X=0) b : Slope of regression line (i.e. rate of change of Y when X is incremented by 1 unit) . For Multiple Linear Regression, equation would be . Y = a + b1X1 + b2X2 + b3X3 + ...... . Let&#39;s start with Linear Regression using Python. For this tutorial, I&#39;ll be using Boston Housing Price Data Set, which is provided in SciKit Learn library SciKit Link. Details about this data set can be found at Link . First import all the required libraries. . import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from scipy import stats from sklearn.datasets import load_boston . We will load the dataset using load_boston method, this will return a Bunch object. Bunch object is like a Python dictionary, let&#39;s quickly look at the significance of keys :- . data &emsp;: &emsp; Data to learn target &emsp;: &emsp; Target column, for this example Median value of owner occupied home will be the target DESCR &emsp;: &emsp; Description of dataset including the headers significance feature_names &emsp;: &emsp; Names of header filename &emsp;: &emsp; Physical location from where the data was created . boston = load_boston() . Quick Analysis of Data Set . print(&quot;Shape for Data is&quot;, boston.data.shape) print(&quot;Shape for Target is&quot;, boston.target.shape) print(&quot;Names of header : n&quot;, boston.feature_names) print(&quot;Dataset description : n&quot;, boston.DESCR) . Shape for Data is (506, 13) Shape for Target is (506,) Names of header : [&#39;CRIM&#39; &#39;ZN&#39; &#39;INDUS&#39; &#39;CHAS&#39; &#39;NOX&#39; &#39;RM&#39; &#39;AGE&#39; &#39;DIS&#39; &#39;RAD&#39; &#39;TAX&#39; &#39;PTRATIO&#39; &#39;B&#39; &#39;LSTAT&#39;] Dataset description : .. _boston_dataset: Boston house prices dataset **Data Set Characteristics:** :Number of Instances: 506 :Number of Attributes: 13 numeric/categorical predictive. Median Value (attribute 14) is usually the target. :Attribute Information (in order): - CRIM per capita crime rate by town - ZN proportion of residential land zoned for lots over 25,000 sq.ft. - INDUS proportion of non-retail business acres per town - CHAS Charles River dummy variable (= 1 if tract bounds river; 0 otherwise) - NOX nitric oxides concentration (parts per 10 million) - RM average number of rooms per dwelling - AGE proportion of owner-occupied units built prior to 1940 - DIS weighted distances to five Boston employment centres - RAD index of accessibility to radial highways - TAX full-value property-tax rate per $10,000 - PTRATIO pupil-teacher ratio by town - B 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town - LSTAT % lower status of the population - MEDV Median value of owner-occupied homes in $1000&#39;s :Missing Attribute Values: None :Creator: Harrison, D. and Rubinfeld, D.L. This is a copy of UCI ML housing dataset. https://archive.ics.uci.edu/ml/machine-learning-databases/housing/ This dataset was taken from the StatLib library which is maintained at Carnegie Mellon University. The Boston house-price data of Harrison, D. and Rubinfeld, D.L. &#39;Hedonic prices and the demand for clean air&#39;, J. Environ. Economics &amp; Management, vol.5, 81-102, 1978. Used in Belsley, Kuh &amp; Welsch, &#39;Regression diagnostics ...&#39;, Wiley, 1980. N.B. Various transformations are used in the table on pages 244-261 of the latter. The Boston house-price data has been used in many machine learning papers that address regression problems. .. topic:: References - Belsley, Kuh &amp; Welsch, &#39;Regression diagnostics: Identifying Influential Data and Sources of Collinearity&#39;, Wiley, 1980. 244-261. - Quinlan,R. (1993). Combining Instance-Based and Model-Based Learning. In Proceedings on the Tenth International Conference of Machine Learning, 236-243, University of Massachusetts, Amherst. Morgan Kaufmann. . # Create a Pandas Data Frame from this data set df = pd.DataFrame(boston.data) df.head(2) . 0 1 2 3 4 5 6 7 8 9 10 11 12 . 0 0.00632 | 18.0 | 2.31 | 0.0 | 0.538 | 6.575 | 65.2 | 4.0900 | 1.0 | 296.0 | 15.3 | 396.9 | 4.98 | . 1 0.02731 | 0.0 | 7.07 | 0.0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2.0 | 242.0 | 17.8 | 396.9 | 9.14 | . As you can see that the data frame has no header names and is also missing our target column. Let&#39;s fix this first :- . df.columns = boston.feature_names df[&#39;MEDV&#39;] = boston.target df.head(2) . CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT MEDV . 0 0.00632 | 18.0 | 2.31 | 0.0 | 0.538 | 6.575 | 65.2 | 4.0900 | 1.0 | 296.0 | 15.3 | 396.9 | 4.98 | 24.0 | . 1 0.02731 | 0.0 | 7.07 | 0.0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2.0 | 242.0 | 17.8 | 396.9 | 9.14 | 21.6 | . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 506 entries, 0 to 505 Data columns (total 14 columns): CRIM 506 non-null float64 ZN 506 non-null float64 INDUS 506 non-null float64 CHAS 506 non-null float64 NOX 506 non-null float64 RM 506 non-null float64 AGE 506 non-null float64 DIS 506 non-null float64 RAD 506 non-null float64 TAX 506 non-null float64 PTRATIO 506 non-null float64 B 506 non-null float64 LSTAT 506 non-null float64 MEDV 506 non-null float64 dtypes: float64(14) memory usage: 55.4 KB . Data Wrangling . If we check our data, it doesn&#39;t seems to have any missing value. So, we will assume this as cleaned data and will use as such. . df.isnull().sum() . CRIM 0 ZN 0 INDUS 0 CHAS 0 NOX 0 RM 0 AGE 0 DIS 0 RAD 0 TAX 0 PTRATIO 0 B 0 LSTAT 0 MEDV 0 dtype: int64 . Exploratory Data Analysis . # Descriptive Statistics df.describe() . CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT MEDV . count 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | 506.000000 | . mean 3.613524 | 11.363636 | 11.136779 | 0.069170 | 0.554695 | 6.284634 | 68.574901 | 3.795043 | 9.549407 | 408.237154 | 18.455534 | 356.674032 | 12.653063 | 22.532806 | . std 8.601545 | 23.322453 | 6.860353 | 0.253994 | 0.115878 | 0.702617 | 28.148861 | 2.105710 | 8.707259 | 168.537116 | 2.164946 | 91.294864 | 7.141062 | 9.197104 | . min 0.006320 | 0.000000 | 0.460000 | 0.000000 | 0.385000 | 3.561000 | 2.900000 | 1.129600 | 1.000000 | 187.000000 | 12.600000 | 0.320000 | 1.730000 | 5.000000 | . 25% 0.082045 | 0.000000 | 5.190000 | 0.000000 | 0.449000 | 5.885500 | 45.025000 | 2.100175 | 4.000000 | 279.000000 | 17.400000 | 375.377500 | 6.950000 | 17.025000 | . 50% 0.256510 | 0.000000 | 9.690000 | 0.000000 | 0.538000 | 6.208500 | 77.500000 | 3.207450 | 5.000000 | 330.000000 | 19.050000 | 391.440000 | 11.360000 | 21.200000 | . 75% 3.677083 | 12.500000 | 18.100000 | 0.000000 | 0.624000 | 6.623500 | 94.075000 | 5.188425 | 24.000000 | 666.000000 | 20.200000 | 396.225000 | 16.955000 | 25.000000 | . max 88.976200 | 100.000000 | 27.740000 | 1.000000 | 0.871000 | 8.780000 | 100.000000 | 12.126500 | 24.000000 | 711.000000 | 22.000000 | 396.900000 | 37.970000 | 50.000000 | . Let&#39;s use some visualization techniques on our data to understand the distribution and relationship of independent variables with our target variable. . For distribution of data, we will use Histogram. Before proceeding, let&#39;s look at what Histogram is :- . A histogram is a type of bar graph that shows the frequency or number of values compared to a set of value ranges. To construct a histogram, the first step is to “bin” the range of values — that is, divide the entire range of values into a series of intervals — and then count how many values fall into each interval. The bins are usually specified as consecutive, non-overlapping intervals of a variable. The bins (intervals) must be adjacent, and are often (but are not required to be) of equal size. . Let&#39;s use histogram to view the data distribution in our case. Look closely at our target (MEDV) and notice that the prices are mainly in the mid range distribution. . df.hist(bins=30, figsize=(18,18)) . array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1cfa5320&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d240780&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d268be0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d29a198&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d2bf710&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d2e7ba8&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d316160&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d33c710&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d33c748&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d394208&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d3ba780&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d3e1cf8&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d4102b0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d437828&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d45eda0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1a1d48e358&gt;]], dtype=object) . To visualize the relationship between independent variables and target variable (MEDV), we will use Regression Plot, which is basically a Scatter Plot with fitted regression line. We use regression plot for variables with continous values, while a box plot will be used for categorical variables. . plt.figure(figsize=(25, 25)) for i, col in enumerate(boston.feature_names): plt.subplot(4, 4 , i+1) sns.regplot(x=col, y=&#39;MEDV&#39;, data=df) plt.title(&quot;%s vs MEDV&quot; %(col)) . Observations so far :- . Variable &#39;RM&#39; seems to have positive linear relationship with target variable &#39;MEDV&#39;. | Variable &#39;LSTAT&#39; seems to have negative linear relationship with target variable &#39;MEDV&#39;. | . Let&#39;s use other statistical methods to confirm our observations. We will use Pearson Corelation as our statistical tool. . What is Pearson Corelation? . A Pearson Corelation is a number between -1 and 1 which indicates the extent to which two variables are linearly related. . Corelation Cofficient: . 1 - Positively correlated -1 - Negatively correlated. 0 - Not correlated. . P-value: . The P-value is the probability value that the correlation between these two variables is statistically significant. . By convention, when the . p-value is &lt; 0.001: we say there is strong evidence that the correlation is significant. the p-value is &lt; 0.05: there is moderate evidence that the correlation is significant. the p-value is &lt; 0.1: there is weak evidence that the correlation is significant. the p-value is &gt; 0.1: there is no evidence that the correlation is significant. . We will use the Pandas data frame method &quot;corr()&quot; to find the co-relation and then use the Seaborn&#39;s Heatmap to plot it. . sns.set(rc={&#39;figure.figsize&#39;:(8,8)}) sns.heatmap(df.corr().round(2), square=True, cmap=&#39;RdYlGn&#39;, annot=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a203d7b70&gt; . We observed visually that attributes &#39;RM&#39; exhibits postive linear relationship, which seems correct as per Corelation Cofficient with a value of 0.7. We also observed that &#39;LSTAT&#39; exhibits negative linear relationship with &#39;MEDV&#39; and this seems to be correct statistically as well with a cofficient value of -0.74. . Let&#39;s also look at the p-value as well. . pearson_coef1, p_value1 = stats.pearsonr(df[&#39;RM&#39;], df[&#39;MEDV&#39;]) print(&quot;The Pearson Correlation Coefficient for RM is&quot;, pearson_coef1, &quot; with a P-value of P = &quot;, p_value1) pearson_coef2, p_value2 = stats.pearsonr(df[&#39;LSTAT&#39;], df[&#39;MEDV&#39;]) print(&quot;The Pearson Correlation Coefficient for LSTAT is&quot;, pearson_coef2, &quot; with a P-value of P = &quot;, p_value2) print(&quot;Is there strong evidence if corelation is signifcant for RM :- &quot;, p_value1 &lt; 0.001) print(&quot;Is there strong evidence if corelation is signifcant for LSTAT :- &quot;, p_value2 &lt; 0.001) . The Pearson Correlation Coefficient for RM is 0.6953599470715393 with a P-value of P = 2.487228871008295e-74 The Pearson Correlation Coefficient for LSTAT is -0.7376627261740147 with a P-value of P = 5.081103394389002e-88 Is there strong evidence if corelation is signifcant for RM :- True Is there strong evidence if corelation is signifcant for LSTAT :- True . As you can notice, our corelation is significant for variables &#39;RM&#39; and &#39;LSTAT&#39;. . Linear Model Creation . Now that we have indentified few variables which appears to have linear relationship with our target data, we will start developing the Linear Regression Model. . We will start with Simple Linear Regression. As stated above, Simple Linear Regression only uses one variable, so we will use only &#39;RM&#39; attribute. . First, we will import the LinearRegression class from the SciKit library and create a LinearRegression object. Then we will train the model, find the slope and intercept and finally we will do some prediction. . NOTE : For this post as part of explaining linear regression model, I will be using the entire data set for training. In real world, we will split the data into test and training data. This will be covered in a later post. . from sklearn.linear_model import LinearRegression # Create Linear Regression Object lm1 = LinearRegression() X1 = df[[&#39;RM&#39;]] Y1 = df[[&#39;MEDV&#39;]] # Target # Fit (Train) the model lm1.fit(X1,Y1) print(&quot;Intercept for the model is&quot;, lm1.intercept_, &quot;and the scope is&quot;,lm1.coef_) # Prediction Yout1 = lm1.predict(X1) # Actual and Predicted values (first five) print(&quot;Predicted Values:&quot;,Yout1[0:5]) print(&quot;Actual Values:&quot;,Y1.values[0:5]) . Intercept for the model is [-34.67062078] and the scope is [[9.10210898]] Predicted Values: [[25.17574577] [23.77402099] [30.72803225] [29.02593787] [30.38215211]] Actual Values: [[24. ] [21.6] [34.7] [33.4] [36.2]] . Now, we will develop the Multiple Linear Regression with two variables - &#39;RM&#39; and &#39;LSTAT&#39;. . lm2 = LinearRegression() X2 = df[[&#39;RM&#39;, &#39;LSTAT&#39;]] Y2 = df[[&#39;MEDV&#39;]] # Fit (Train) the model lm2.fit(X2,Y2) print(&quot;Intercept for the model is&quot;, lm2.intercept_, &quot;and the scope is&quot;,lm2.coef_) # Prediction Yout2 = lm2.predict(X2) # Actual and Predicted values (first five) print(&quot;Predicted Values:&quot;,Yout2[0:5]) print(&quot;Actual Values:&quot;,Y2.values[0:5]) . Intercept for the model is [-1.35827281] and the scope is [[ 5.09478798 -0.64235833]] Predicted Values: [[28.94101368] [25.48420566] [32.65907477] [32.40652 ] [31.63040699]] Actual Values: [[24. ] [21.6] [34.7] [33.4] [36.2]] . Model Visualization . We will visualize our models that we have created. For Simple Linear Regression, we can either use Regression Plot or Residual Plot. In case of regression plot, we need to focus on spread of data from regression line. If the data is too far from regression line, then we can say that Linear Model is not the best fit. . Since we have already used Regression Plot, we will use Residual Plot. A Residual is the difference between observed value (Y) and predicted value (Yout). In residual plot, X-axis will have independent variable and Y-Axis will have residuals. . What to look in residual plot? . If the points in a residual plot are randomly spread out around the x-axis, then a linear model is appropriate for the data. Randomly spread out residuals means that the variance is constant, and thus the linear model is a good fit for this data. | . # Seaborn library to be used for Residual Plot plt.figure(figsize=(6,6)) sns.residplot(df[&#39;RM&#39;],df[&#39;MEDV&#39;]) plt.show() . For Multiple Linear Regression, we can&#39;t use Regression or Residual Plot because of multiple independent variables, so we will use Distribution Plot. . plt.figure(figsize=(6,6)) ax1 = sns.distplot(df[&#39;MEDV&#39;], hist=False, color=&quot;r&quot;, label=&quot;Actual&quot;) sns.distplot(Yout2, hist=False, color=&quot;b&quot;, label=&quot;Fitted&quot;, ax=ax1) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1e74a748&gt; . Model Accuracy . We will use the following quantitative methods for finding model accuracy. . Mean Squared Error (MSE) . The Mean Squared Error measures the average of the squares of errors. It is calculated by :- . Finding the error between actual and predicted value | Taking a square of it | Sum up all the values | Divide by number of values | . R-squared . R squared, also known as the coefficient of determination is a measure to indicate how close the data is to the fitted regression line. . R^2 = 1 - MSE of regression line / MSE of average of data . Which one is better model? . Model will less MSE and high R-Square value | . We can use the sklearn.metrics.mean_squared_error to find the Mean Squared Error and model score() method to obtain R-Square value. . from sklearn.metrics import mean_squared_error # Simple Linear Regression mse1 = mean_squared_error(Y1,Yout1) print(&quot;Mean square error for simple linear regression is&quot;,mse1) print(&quot;R-Square value for simple linear regression is&quot;, lm1.score(X1,Y1)) print(&quot; n&quot;) # Multiple Linear Regression mse2 = mean_squared_error(Y2,Yout2) print(&quot;Mean square error for mulitple linear regression is&quot;,mse2) print(&quot;R-Square value for multiple linear regression is&quot;, lm2.score(X2,Y2)) . Mean square error for simple linear regression is 43.60055177116956 R-Square value for simple linear regression is 0.4835254559913343 Mean square error for mulitple linear regression is 30.51246877729947 R-Square value for multiple linear regression is 0.6385616062603403 . We can see that the multiple linear regression model seems to perform better because of high R-Square value and low mean square error. . Model Evaluation : Train and Test Data, Cross Validation . As I mentioned before, in real-world we will split our data into test and training data to evaluate our model. We will use &quot;train_test_split&quot; method to split our data into testing and training data. In this section, I will be using Multiple Regression Model to illustrate this process. . # First step that we will take is to seperate target data y_data = df[&#39;MEDV&#39;] x_data = df.drop(&#39;MEDV&#39;,axis=1) from sklearn.model_selection import train_test_split # Split the data into test and training (15% as test data) x_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.15, random_state=10) print(&quot;Number of test samples :&quot;, x_test.shape[0]) print(&quot;Number of training samples:&quot;,x_train.shape[0]) lm = LinearRegression() # Fit (Train) the model using the training data lm.fit(x_train[[&#39;RM&#39;,&#39;LSTAT&#39;]],y_train) # Prediction using Training Data yout_train = lm.predict(x_train[[&#39;RM&#39;,&#39;LSTAT&#39;]]) print(yout_train[0:5]) # Prediction using Test Data yout_test = lm.predict(x_test[[&#39;RM&#39;,&#39;LSTAT&#39;]]) print(yout_test[0:5]) print(&quot; n&quot;) # Model accuracy using Test Data mse_test = mean_squared_error(y_test,yout_test) print(&quot;Mean square error is&quot;,mse_test) print(&quot;R-Square value using test data is&quot;, lm.score(x_test[[&#39;RM&#39;,&#39;LSTAT&#39;]],y_test)) print(&quot; n&quot;) # Model accuracy using Training Data mse_train = mean_squared_error(y_train,yout_train) print(&quot;Mean square error is&quot;,mse_train) print(&quot;R-Square value using training data is&quot;, lm.score(x_train[[&#39;RM&#39;,&#39;LSTAT&#39;]],y_train)) . Number of test samples : 76 Number of training samples: 430 [38.74400503 5.69000561 19.41554723 30.26876646 21.13562849] [26.21310048 29.61955969 27.50797208 29.69508151 17.77881853] Mean square error is 47.91753944668556 R-Square value using test data is 0.5784951912105682 Mean square error is 27.636206385020866 R-Square value using training data is 0.6375993387266081 . Cross Validation : . Division of data into testing and training data may result into a problem especially if the data is sorted by some particular features and our testing data does not have that data. With Cross Validation, we will use entire subset of data for training and testing in iterations. This is just a brief introduction on this topic and there are other methods to perform cross validation. . In the example below, we are using K-Fold validation technique and dividing our data into 5 folds and each of the fold will be used as a test data. We will then take the mean of all the iterations. . from sklearn.model_selection import cross_val_score, KFold rcross = cross_val_score(lm, x_data, y_data, cv=KFold(n_splits=5,shuffle=True)) print(rcross) print(&quot;The mean of the folds are&quot;, rcross.mean()) . [0.62229666 0.7348349 0.74170714 0.65677571 0.77563056] The mean of the folds are 0.7062489913934608 .",
            "url": "https://sarbjit87.github.io/ml-blog/machine_learning/2020/05/12/Linear_Regression.html",
            "relUrl": "/machine_learning/2020/05/12/Linear_Regression.html",
            "date": " • May 12, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://sarbjit87.github.io/ml-blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://sarbjit87.github.io/ml-blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://sarbjit87.github.io/ml-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sarbjit87.github.io/ml-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}